import Resolver from '@forge/resolver';
import api, { route, storage } from '@forge/api';

const resolver = new Resolver();

// ============ CONSTANTS ============
const WORKING_DAYS_DEFAULT = 10;
const HOURS_PER_DAY = 8;

// ============ HELPER FUNCTIONS ============

/**
 * Check if date is working day (Monday-Friday)
 */
const isWorkingDay = (date) => {
  const day = new Date(date).getDay();
  return day !== 0 && day !== 6;
};

/**
 * Count working days between two dates
 */
const countWorkingDays = (startDate, endDate) => {
  let count = 0;
  const current = new Date(startDate);
  const end = new Date(endDate);
  
  while (current <= end) {
    if (isWorkingDay(current)) count++;
    current.setDate(current.getDate() + 1);
  }
  return count || WORKING_DAYS_DEFAULT;
};

/**
 * Convert Jira time (seconds) to hours
 */
const secondsToHours = (seconds) => {
  if (!seconds) return 0;
  return Math.round((seconds / 3600) * 10) / 10;
};

/**
 * Format date to display string
 */
const formatDate = (dateStr) => {
  const date = new Date(dateStr);
  return date.toLocaleDateString('en-US', { month: 'short', day: '2-digit' });
};

// ============ JIRA API CALLS ============

/**
 * Get all Scrum boards
 */
const getBoards = async () => {
  const response = await api.asUser().requestJira(
    route`/rest/agile/1.0/board?type=scrum&maxResults=50`,
    { headers: { 'Accept': 'application/json' } }
  );
  
  if (!response.ok) {
    throw new Error(`Failed to fetch boards: ${response.status}`);
  }
  
  const data = await response.json();
  return data.values || [];
};

/**
 * Get active sprint for a board
 */
const getActiveSprint = async (boardId) => {
  const response = await api.asUser().requestJira(
    route`/rest/agile/1.0/board/${boardId}/sprint?state=active`,
    { headers: { 'Accept': 'application/json' } }
  );
  
  if (!response.ok) {
    return null;
  }
  
  const data = await response.json();
  return data.values?.[0] || null;
};

/**
 * Get sprint details
 */
const getSprint = async (sprintId) => {
  const response = await api.asUser().requestJira(
    route`/rest/agile/1.0/sprint/${sprintId}`,
    { headers: { 'Accept': 'application/json' } }
  );
  
  if (!response.ok) {
    return null;
  }
  
  return await response.json();
};

/**
 * Get sprint issues with all required fields
 */
const getSprintIssues = async (sprintId) => {
  const jql = `sprint = ${sprintId}`;
  const fields = [
    'summary', 'status', 'priority', 'assignee',
    'timeoriginalestimate', 'timeestimate', 'timespent',
    'duedate', 'created', 'updated'
  ].join(',');
  
  const response = await api.asUser().requestJira(
    route`/rest/api/3/search?jql=${jql}&maxResults=200&fields=${fields}`,
    { headers: { 'Accept': 'application/json' } }
  );
  
  if (!response.ok) {
    throw new Error(`Failed to fetch issues: ${response.status}`);
  }
  
  const data = await response.json();
  return data.issues || [];
};

// ============ RESOLVERS ============

/**
 * Get available Scrum boards for configuration
 */
resolver.define('getBoards', async () => {
  try {
    const boards = await getBoards();
    return { 
      success: true, 
      boards: boards.map(b => ({ 
        id: b.id, 
        name: b.name,
        projectKey: b.location?.projectKey 
      }))
    };
  } catch (error) {
    console.error('Error fetching boards:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Get gadget configuration from storage
 */
resolver.define('getConfig', async ({ context }) => {
  try {
    const gadgetId = context.extension?.gadget?.id || 'default';
    const config = await storage.get(`config-${gadgetId}`);
    return config || { boardId: null, teamSize: 10, workingDays: 10 };
  } catch (error) {
    console.error('Error getting config:', error);
    return { boardId: null, teamSize: 10, workingDays: 10 };
  }
});

/**
 * Save gadget configuration to storage
 */
resolver.define('saveConfig', async ({ payload, context }) => {
  try {
    const gadgetId = context.extension?.gadget?.id || 'default';
    await storage.set(`config-${gadgetId}`, payload);
    return { success: true };
  } catch (error) {
    console.error('Error saving config:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Get Burndown Chart data
 * 
 * IMPORTANT: Ideal Line is based on MAX CAPACITY, not original estimate!
 * MAX CAPACITY = Working Days × 8 hours × Team Size
 */
resolver.define('getBurndownData', async ({ payload }) => {
  try {
    const { boardId, assignee, teamSize: configTeamSize } = payload;
    
    if (!boardId) {
      return { success: false, error: 'Board ID is required' };
    }
    
    // Get active sprint
    const sprint = await getActiveSprint(boardId);
    if (!sprint) {
      return { success: false, error: 'No active sprint found' };
    }
    
    // Get sprint issues
    let issues = await getSprintIssues(sprint.id);
    
    // Get unique assignees
    const allAssignees = [...new Set(
      issues
        .map(i => i.fields.assignee?.displayName)
        .filter(Boolean)
    )];
    
    // Filter by assignee if specified
    let teamSize = configTeamSize || allAssignees.length || 1;
    if (assignee && assignee !== 'All') {
      issues = issues.filter(i => 
        i.fields.assignee?.displayName === assignee ||
        i.fields.assignee?.accountId === assignee
      );
      teamSize = 1;
    }
    
    // Calculate dates
    const startDate = new Date(sprint.startDate);
    const endDate = new Date(sprint.endDate);
    const workingDays = countWorkingDays(startDate, endDate);
    
    // MAX CAPACITY = WORKING_DAYS × 8 hours × team_size
    const maxCapacity = workingDays * HOURS_PER_DAY * teamSize;
    
    // Calculate totals
    const totalOriginal = issues.reduce((sum, issue) => 
      sum + secondsToHours(issue.fields.timeoriginalestimate), 0
    );
    
    const currentRemaining = issues.reduce((sum, issue) => 
      sum + secondsToHours(issue.fields.timeestimate), 0
    );
    
    const totalSpent = issues.reduce((sum, issue) => 
      sum + secondsToHours(issue.fields.timespent), 0
    );
    
    // Generate data points
    const dataPoints = [];
    const current = new Date(startDate);
    let workingDayCount = 0;
    const dailyDecrease = maxCapacity / workingDays;
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    
    while (current <= endDate) {
      if (isWorkingDay(current) && current > startDate) {
        workingDayCount++;
      }
      
      // IDEAL: Based on MAX CAPACITY, decreasing linearly
      const ideal = Math.max(0, maxCapacity - (dailyDecrease * workingDayCount));
      
      const dateStr = current.toISOString().split('T')[0];
      const currentDate = new Date(current);
      currentDate.setHours(0, 0, 0, 0);
      
      // Only show remaining for past/today dates
      const isPastOrToday = currentDate <= today;
      
      dataPoints.push({
        date: dateStr,
        displayDate: formatDate(dateStr),
        ideal: Math.round(ideal * 10) / 10,
        remaining: isPastOrToday ? currentRemaining : null,
        timeLogged: isPastOrToday ? totalSpent : null,
        added: 0,  // Would need changelog tracking
        removed: 0 // Would need changelog tracking
      });
      
      current.setDate(current.getDate() + 1);
    }
    
    return {
      success: true,
      data: {
        dataPoints,
        sprintName: sprint.name,
        sprintId: sprint.id,
        startDate: sprint.startDate,
        endDate: sprint.endDate,
        maxCapacity: Math.round(maxCapacity * 10) / 10,
        totalOriginal: Math.round(totalOriginal * 10) / 10,
        currentRemaining: Math.round(currentRemaining * 10) / 10,
        totalSpent: Math.round(totalSpent * 10) / 10,
        workingDays,
        teamSize,
        assignees: allAssignees
      }
    };
  } catch (error) {
    console.error('Error in getBurndownData:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Get Sprint Health data
 * 
 * Classification:
 * - UNDERESTIMATED: Original < (Spent + Remaining)
 * - NORMAL: Original == (Spent + Remaining)  
 * - GOOD: Original > (Spent + Remaining)
 */
resolver.define('getSprintHealth', async ({ payload }) => {
  try {
    const { boardId, assignee } = payload;
    
    if (!boardId) {
      return { success: false, error: 'Board ID is required' };
    }
    
    const sprint = await getActiveSprint(boardId);
    if (!sprint) {
      return { success: false, error: 'No active sprint found' };
    }
    
    let issues = await getSprintIssues(sprint.id);
    
    // Filter by assignee
    if (assignee && assignee !== 'All') {
      issues = issues.filter(i => 
        i.fields.assignee?.displayName === assignee
      );
    }
    
    // Calculate health
    let underCount = 0, normalCount = 0, goodCount = 0;
    const details = [];
    
    issues.forEach(issue => {
      const original = secondsToHours(issue.fields.timeoriginalestimate);
      const spent = secondsToHours(issue.fields.timespent);
      const remaining = secondsToHours(issue.fields.timeestimate);
      const actualTotal = spent + remaining;
      const variance = actualTotal - original;
      
      let status;
      if (original < actualTotal) {
        status = 'underestimated';
        underCount++;
      } else if (original > actualTotal) {
        status = 'good';
        goodCount++;
      } else {
        status = 'normal';
        normalCount++;
      }
      
      details.push({
        key: issue.key,
        summary: issue.fields.summary,
        status,
        original,
        spent,
        remaining,
        variance: Math.round(variance * 10) / 10
      });
    });
    
    return {
      success: true,
      data: {
        counts: {
          under: underCount,
          normal: normalCount,
          good: goodCount,
          total: issues.length
        },
        details,
        sprintName: sprint.name
      }
    };
  } catch (error) {
    console.error('Error in getSprintHealth:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Get At Risk Items
 * 
 * Triggers:
 * - TIME_BOX_EXCEEDED: Remaining = 0 AND Status != Done
 * - DEADLINE_EXCEEDED: Due Date <= Today AND Status != Done
 */
resolver.define('getAtRiskItems', async ({ payload }) => {
  try {
    const { boardId, assignee } = payload;
    
    if (!boardId) {
      return { success: false, error: 'Board ID is required' };
    }
    
    const sprint = await getActiveSprint(boardId);
    if (!sprint) {
      return { success: false, error: 'No active sprint found' };
    }
    
    let issues = await getSprintIssues(sprint.id);
    
    if (assignee && assignee !== 'All') {
      issues = issues.filter(i => 
        i.fields.assignee?.displayName === assignee
      );
    }
    
    const atRiskItems = [];
    const doneStatuses = ['done', 'closed', 'resolved', 'complete'];
    const now = new Date();
    now.setHours(0, 0, 0, 0);
    
    issues.forEach(issue => {
      const status = issue.fields.status?.name?.toLowerCase() || '';
      
      // Skip done issues
      if (doneStatuses.some(s => status.includes(s))) return;
      
      let riskReason = null;
      const remaining = secondsToHours(issue.fields.timeestimate);
      const original = secondsToHours(issue.fields.timeoriginalestimate);
      const dueDate = issue.fields.duedate ? new Date(issue.fields.duedate) : null;
      
      // Check Time Box Exceeded
      if (remaining === 0 && original > 0) {
        riskReason = 'TIME_BOX_EXCEEDED';
      }
      
      // Check Deadline Exceeded (takes precedence)
      if (dueDate) {
        dueDate.setHours(0, 0, 0, 0);
        if (dueDate <= now) {
          riskReason = 'DEADLINE_EXCEEDED';
        }
      }
      
      if (riskReason) {
        atRiskItems.push({
          key: issue.key,
          summary: issue.fields.summary,
          assignee: issue.fields.assignee?.displayName || 'Unassigned',
          assigneeAvatar: issue.fields.assignee?.avatarUrls?.['24x24'],
          priority: issue.fields.priority?.name || 'Medium',
          status: issue.fields.status?.name || 'To Do',
          dueDate: issue.fields.duedate,
          originalEstimate: original,
          remainingEstimate: remaining,
          riskReason
        });
      }
    });
    
    // Sort: Due Date ASC, then Priority DESC
    const priorityOrder = { 'Highest': 1, 'High': 2, 'Medium': 3, 'Low': 4, 'Lowest': 5 };
    atRiskItems.sort((a, b) => {
      const dateA = a.dueDate ? new Date(a.dueDate) : new Date('9999-12-31');
      const dateB = b.dueDate ? new Date(b.dueDate) : new Date('9999-12-31');
      if (dateA.getTime() !== dateB.getTime()) return dateA - dateB;
      return (priorityOrder[a.priority] || 3) - (priorityOrder[b.priority] || 3);
    });
    
    return {
      success: true,
      data: {
        items: atRiskItems,
        total: atRiskItems.length,
        sprintName: sprint.name
      }
    };
  } catch (error) {
    console.error('Error in getAtRiskItems:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Get Scope Changes
 * 
 * Types:
 * - ADDED: Created after sprint start
 * - REMOVED: Would need changelog tracking
 * - PRIORITY: Would need changelog tracking
 */
resolver.define('getScopeChanges', async ({ payload }) => {
  try {
    const { boardId, assignee } = payload;
    
    if (!boardId) {
      return { success: false, error: 'Board ID is required' };
    }
    
    const sprint = await getActiveSprint(boardId);
    if (!sprint) {
      return { success: false, error: 'No active sprint found' };
    }
    
    let issues = await getSprintIssues(sprint.id);
    
    if (assignee && assignee !== 'All') {
      issues = issues.filter(i => 
        i.fields.assignee?.displayName === assignee
      );
    }
    
    const sprintStart = new Date(sprint.startDate);
    const added = [];
    const removed = [];
    const priorityChanged = [];
    
    issues.forEach(issue => {
      const created = new Date(issue.fields.created);
      
      // If created after sprint start, it was added
      if (created > sprintStart) {
        added.push({
          key: issue.key,
          summary: issue.fields.summary,
          assignee: issue.fields.assignee?.displayName || 'Unassigned',
          assigneeAvatar: issue.fields.assignee?.avatarUrls?.['24x24'],
          priority: issue.fields.priority?.name,
          status: issue.fields.status?.name,
          changeType: 'ADDED',
          changeDate: issue.fields.created,
          originalEstimate: secondsToHours(issue.fields.timeoriginalestimate),
          remainingEstimate: secondsToHours(issue.fields.timeestimate)
        });
      }
    });
    
    // Note: For removed and priority changes, you'd need to track changelog
    // This is a simplified version
    
    return {
      success: true,
      data: {
        added,
        removed,
        priorityChanged,
        totalAdded: added.length,
        totalRemoved: removed.length,
        totalPriorityChanged: priorityChanged.length,
        sprintName: sprint.name
      }
    };
  } catch (error) {
    console.error('Error in getScopeChanges:', error);
    return { success: false, error: error.message };
  }
});

/**
 * Get High Priority Items
 * 
 * Filter: Priority = Highest OR High
 */
resolver.define('getHighPriorityItems', async ({ payload }) => {
  try {
    const { boardId, assignee } = payload;
    
    if (!boardId) {
      return { success: false, error: 'Board ID is required' };
    }
    
    const sprint = await getActiveSprint(boardId);
    if (!sprint) {
      return { success: false, error: 'No active sprint found' };
    }
    
    let issues = await getSprintIssues(sprint.id);
    
    if (assignee && assignee !== 'All') {
      issues = issues.filter(i => 
        i.fields.assignee?.displayName === assignee
      );
    }
    
    // Filter high priority
    const highPriorityItems = issues
      .filter(issue => {
        const priority = issue.fields.priority?.name?.toLowerCase();
        return priority === 'highest' || priority === 'high';
      })
      .map(issue => ({
        key: issue.key,
        summary: issue.fields.summary,
        assignee: issue.fields.assignee?.displayName || 'Unassigned',
        assigneeAvatar: issue.fields.assignee?.avatarUrls?.['24x24'],
        priority: issue.fields.priority?.name,
        status: issue.fields.status?.name,
        dueDate: issue.fields.duedate,
        originalEstimate: secondsToHours(issue.fields.timeoriginalestimate),
        remainingEstimate: secondsToHours(issue.fields.timeestimate),
        timeSpent: secondsToHours(issue.fields.timespent)
      }));
    
    // Sort: Priority (Highest first), then Status (not done first), then Due Date
    const doneStatuses = ['done', 'closed', 'resolved'];
    highPriorityItems.sort((a, b) => {
      // Priority
      const pA = a.priority === 'Highest' ? 1 : 2;
      const pB = b.priority === 'Highest' ? 1 : 2;
      if (pA !== pB) return pA - pB;
      
      // Status (not done first)
      const aIsDone = doneStatuses.some(s => a.status?.toLowerCase().includes(s));
      const bIsDone = doneStatuses.some(s => b.status?.toLowerCase().includes(s));
      if (aIsDone !== bIsDone) return aIsDone ? 1 : -1;
      
      // Due Date
      const dateA = a.dueDate ? new Date(a.dueDate) : new Date('9999-12-31');
      const dateB = b.dueDate ? new Date(b.dueDate) : new Date('9999-12-31');
      return dateA - dateB;
    });
    
    return {
      success: true,
      data: {
        items: highPriorityItems,
        total: highPriorityItems.length,
        highestCount: highPriorityItems.filter(i => i.priority === 'Highest').length,
        highCount: highPriorityItems.filter(i => i.priority === 'High').length,
        sprintName: sprint.name
      }
    };
  } catch (error) {
    console.error('Error in getHighPriorityItems:', error);
    return { success: false, error: error.message };
  }
});

export const handler = resolver.getDefinitions();
